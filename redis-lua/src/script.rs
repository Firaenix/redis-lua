/// Script information which is generated by proc-macro.
#[derive(Clone, Debug)]
pub struct Info {
    /// The entire script including arguments initialization.
    script: &'static str,
    /// The script excluding arguments initialization.
    body: &'static str,
    /// The list of arguments.
    args: &'static [&'static str],
}

impl Info {
    /// Create the new script information.
    pub fn new(script: &'static str, body: &'static str, args: &'static [&'static str]) -> Self {
        Self { script, body, args }
    }
}

/// To make sure `Script` be object safe.
fn _object_safe(_: &dyn Script) {}

/// Represents a complete invocable script which has a complete set of arguments.
pub trait Script {
    /// Pass all the arguments to the given script invocation.
    /// Panic if it is called more than once.
    #[doc(hidden)]
    fn apply(&mut self, invoke: &mut redis::ScriptInvocation);

    /// Retrieve all the script information.
    fn info(&self, _: &mut Vec<Info>);

    /// Join another script making self as inner.
    fn join<T: Script>(self, other: T) -> ScriptJoin<Self, T>
    where
        Self: Sized,
    {
        ScriptJoin(self, other)
    }

    /// Invoke the script.
    fn invoke<T>(mut self, con: &mut dyn redis::ConnectionLike) -> redis::RedisResult<T>
    where
        T: redis::FromRedisValue,
        Self: Sized,
    {
        let mut info = vec![];
        self.info(&mut info);
        let script = gen_script(&info);
        let mut invoke = script.prepare_invoke();
        self.apply(&mut invoke);
        invoke.invoke(con)
    }

    /// Invoke the script asynchronously.
    fn invoke_async<C, T>(mut self, con: C) -> redis::RedisFuture<(C, T)>
    where
        C: redis::aio::ConnectionLike + Clone + Send + 'static,
        T: redis::FromRedisValue + Send + 'static,
        Self: Sized,
    {
        let mut info = vec![];
        self.info(&mut info);
        let script = gen_script(&info);
        let mut invoke = script.prepare_invoke();
        self.apply(&mut invoke);
        Box::new(invoke.invoke_async(con))
    }
}

impl<S: Script + ?Sized> Script for Box<S> {
    fn apply(&mut self, invoke: &mut redis::ScriptInvocation) {
        (**self).apply(invoke);
    }

    fn info(&self, infos: &mut Vec<Info>) {
        (**self).info(infos);
    }
}

impl Script for () {
    fn apply(&mut self, _: &mut redis::ScriptInvocation) {}

    fn info(&self, _: &mut Vec<Info>) {}
}

/// Represents the set of two scripts which are joined.
pub struct ScriptJoin<S, T>(S, T);

impl<S, T> Script for ScriptJoin<S, T>
where
    S: Script,
    T: Script,
{
    fn apply(&mut self, invoke: &mut redis::ScriptInvocation) {
        self.0.apply(invoke);
        self.1.apply(invoke);
    }

    fn info(&self, info: &mut Vec<Info>) {
        self.0.info(info);
        self.1.info(info);
    }
}

// Support addition of boxed scripts.
impl<T> std::ops::Add<T> for Box<dyn Script>
where
    T: Script + 'static,
{
    type Output = Box<dyn Script>;

    fn add(self, other: T) -> Self::Output {
        Box::new(self.join(other))
    }
}

/// Take another script as the inner of the script.
pub trait TakeScript<I> {
    type Item;

    /// Take the inner script.
    fn take(self, inner: I) -> Self::Item;
}

/// Generate a script from a list of script information.
pub fn gen_script(info: &[Info]) -> redis::Script {
    if info.len() == 1 {
        // Single script
        let script = info.get(0).expect("At leasts one script must exist").script;
        redis::Script::new(script)
    } else {
        // Generate the joined script.
        let mut arg_index = 0;
        let mut script = String::new();
        let last = info.len() - 1;
        for (index, info) in info.iter().enumerate() {
            let prefix = if index == last { "return " } else { "" };
            let mut init = String::new();

            for arg in info.args {
                arg_index += 1;
                init += &format!("local {} = ARGV[{}] ", arg, arg_index);
            }

            script += &format!("{}(function() {} {} end)();\n", prefix, init, info.body);
        }
        redis::Script::new(&script)
    }
}

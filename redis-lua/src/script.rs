/// Script information which is generated by proc-macro.
#[derive(Clone, Debug)]
pub struct Info {
    /// The entire script including arguments initialization.
    script: &'static str,
    /// The script excluding arguments initialization.
    body: &'static str,
    /// The list of arguments.
    args: Vec<Arg>,
}

impl Info {
    /// Create the new script information.
    pub fn new(script: &'static str, body: &'static str, args: Vec<Arg>) -> Self {
        Self { script, body, args }
    }

    pub fn update_pack(&mut self, index: usize, pack: bool) {
        self.args[index].update_pack(pack);
    }
}

#[derive(Clone, Debug)]
pub struct Arg {
    name: &'static str,
    pack: bool,
}

impl Arg {
    pub fn new(name: &'static str) -> Self {
        Self { name, pack: false }
    }

    pub fn update_pack(&mut self, pack: bool) {
        self.pack = pack;
    }

    pub fn pack(&self) -> bool {
        self.pack
    }
}

/// To make sure `Script` be object safe.
fn _object_safe(_: &dyn Script) {}

/// Represents a complete invocable script which has a complete set of arguments.
pub trait Script {
    /// Pass all the arguments to the given script invocation.
    /// Panic if it is called more than once.
    #[doc(hidden)]
    fn apply(&mut self, invoke: &mut redis::ScriptInvocation);

    /// Retrieve all the script information.
    fn info(&self, _: &mut Vec<Info>);

    /// Join another script making self as inner.
    fn join<T: Script>(self, other: T) -> ScriptJoin<Self, T>
    where
        Self: Sized,
    {
        ScriptJoin(self, other)
    }

    /// Invoke the script.
    fn invoke<T>(mut self, con: &mut dyn redis::ConnectionLike) -> redis::RedisResult<T>
    where
        T: redis::FromRedisValue,
        Self: Sized,
    {
        let mut info = vec![];
        self.info(&mut info);
        let script = gen_script(&info);
        let mut invoke = script.prepare_invoke();
        self.apply(&mut invoke);
        invoke.invoke(con)
    }

    /// Invoke the script asynchronously.
    fn invoke_async<C, T>(mut self, con: C) -> redis::RedisFuture<(C, T)>
    where
        C: redis::aio::ConnectionLike + Clone + Send + 'static,
        T: redis::FromRedisValue + Send + 'static,
        Self: Sized,
    {
        let mut info = vec![];
        self.info(&mut info);
        let script = gen_script(&info);
        let mut invoke = script.prepare_invoke();
        self.apply(&mut invoke);
        Box::new(invoke.invoke_async(con))
    }
}

impl<S: Script + ?Sized> Script for Box<S> {
    fn apply(&mut self, invoke: &mut redis::ScriptInvocation) {
        (**self).apply(invoke);
    }

    fn info(&self, infos: &mut Vec<Info>) {
        (**self).info(infos);
    }
}

impl Script for () {
    fn apply(&mut self, _: &mut redis::ScriptInvocation) {}

    fn info(&self, _: &mut Vec<Info>) {}
}

/// Represents the set of two scripts which are joined.
pub struct ScriptJoin<S, T>(S, T);

impl<S, T> Script for ScriptJoin<S, T>
where
    S: Script,
    T: Script,
{
    fn apply(&mut self, invoke: &mut redis::ScriptInvocation) {
        self.0.apply(invoke);
        self.1.apply(invoke);
    }

    fn info(&self, info: &mut Vec<Info>) {
        self.0.info(info);
        self.1.info(info);
    }
}

/// Take another script as the inner of the script.
pub trait TakeScript<I> {
    type Item;

    /// Take the inner script.
    fn take(self, inner: I) -> Self::Item;
}

/// Generate a script from a list of script information.
pub fn gen_script(info: &[Info]) -> redis::Script {
    assert!(info.len() > 0, "No script information");

    // Generate the joined script.
    let mut arg_index = 0;
    let mut script = String::new();
    let last = info.len() - 1;
    for (index, info) in info.iter().enumerate() {
        let prefix = if index == last { "return " } else { "" };
        let mut init = String::new();

        for arg in &info.args {
            arg_index += 1;

            if arg.pack() {
                init += &format!("local {} = cmsgpack.unpack(ARGV[{}]) ", arg.name, arg_index);
            } else {
                init += &format!("local {} = ARGV[{}] ", arg.name, arg_index);
            }
        }

        script += &format!("{}(function() {} {} end)();\n", prefix, init, info.body);
    }
    redis::Script::new(&script)
}
